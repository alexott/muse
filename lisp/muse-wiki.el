;;; muse-wiki.el --- wiki features for muse

;; Copyright (C) 2005  Free Software Foundation, Inc.

;; Author: Yann Hodique <Yann.Hodique@lifl.fr>
;; Keywords:

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:

;;; Code:

(require 'muse-regexps)
(require 'muse-mode)

(eval-when-compile
  (require 'muse-colors))

(defgroup muse-wiki nil
  "Options controlling the behavior of Emacs Muse Wiki features."
  :group 'muse-mode)

(defun muse-wiki-update-wikiword-regexp (sym val)
  "Update everything related to `muse-wiki-wikiword-regexp'"
  (set sym val)
  (if (featurep 'muse-colors)
      (muse-configure-highlighting 'muse-colors-markup muse-colors-markup)))

(defcustom muse-wiki-hide-nop-tag t
  "If non-nil, hide <nop> tags when coloring a Muse buffer."
  :type 'boolean
  :group 'muse-wiki)

(defcustom muse-wiki-wikiword-regexp
  (concat "\\<\\(\\(?:[" muse-regexp-upper
          "][" muse-regexp-lower "]+\\)\\(?:["
          muse-regexp-upper "][" muse-regexp-lower "]+\\)+\\)\\>")
  "Regexp used to match WikiWords"
  :type 'regexp
  :group 'muse-wiki
  :set 'muse-wiki-update-wikiword-regexp)

(defcustom muse-wiki-use-wikiword t
  "Wether to use WikiWord syntax or not"
  :type 'boolean
  :group 'muse-wiki)

(defvar muse-wiki-interwiki-regexp ""
  "Regexp that matches all interwiki links.
This is automatically generated by setting `muse-wiki-interwiki-alist'.
It can also be set by calling `muse-wiki-update-interwiki-regexp'.")

(defun muse-wiki-update-interwiki-regexp (value)
  "Update the value of `muse-wiki-interwiki-regexp' based on VALUE
and `muse-project-alist'."
  (setq muse-wiki-interwiki-regexp
        (concat "\\<\\(" (mapconcat 'car muse-project-alist "\\|")
                (when value (concat "\\|" (mapconcat 'car value "\\|")))
                "\\)\\(?:\\(?:#\\|::\\)\\(\\sw+\\)\\)?\\>"))
  (muse-configure-highlighting 'muse-colors-markup muse-colors-markup))

(defcustom muse-wiki-interwiki-alist
  '(("EmacsWiki" . "http://www.emacswiki.org/cgi-bin/wiki/"))
  "A table of WikiNames that refer to external entities.
The format of this table is an alist, or series of cons cells.
Each cons cell must be of the form:

  (WIKINAME . STRING-OR-FUNCTION)

The second part of the cons cell may either be a STRING, which in most
cases should be a URL, or a FUNCTION.  If a function, it will be
called with one argument: the tag applied to the Interwiki name, or
nil if no tag was used.  If the cdr was a STRING and a tag is used,
the tag is simply appended.

Here are some examples:

  (\"JohnWiki\" . \"http://alice.dynodns.net/wiki?\")

Referring to [[JohnWiki::EmacsModules]] then really means:

  http://alice.dynodns.net/wiki?EmacsModules

If a function is used for the replacement text, you can get creative
depending on what the tag is.  Tags may contain any alphabetic
character, any number, % or _.  If you need other special characters,
use % to specify the hex code, as in %2E.  All browsers should support
this."
  :type '(repeat (cons (string :tag "WikiName")
                       (choice (string :tag "URL") function)))
  :set (function
        (lambda (sym value)
          (muse-wiki-update-interwiki-regexp value)
          (set sym value)))
  :group 'muse-wiki)

(defun muse-wiki-resolve-project-page (&optional project page)
  "Return the published path from the current page to PAGE of PROJECT.
If PAGE is not specified, use the value of :default in PROJECT.
If PROJECT is not specified, default to first project of
`muse-projects-alist'.

Note that PAGE can have several output directories.  If this is
the case, we will use the first one that matches our current
style and ignore the others."
  (setq project (or project (caar muse-project-alist))
        page (or page (muse-get-keyword :default
                                        (cadr (muse-project project)))))
  (let* ((page-path (muse-project-page-file page project))
         (remote-style (when page-path (car (muse-project-applicable-styles
                                             page-path project))))
         (local-style (car (muse-project-applicable-styles
                            (or muse-publishing-current-file buffer-file-name
                                ;; astonishingly, sometimes even
                                ;; buffer-file-name is not set!
                                (concat default-directory (buffer-name)))
                            (cddr (muse-project-of-file))))))
    (when remote-style
      (let ((output
             (file-relative-name (expand-file-name
                                  page (muse-style-element :path remote-style))
                                 (expand-file-name
                                  (muse-style-element :path local-style)))))
        (if muse-publishing-p
            (muse-publish-output-file output nil remote-style)
          output)))))

(defun muse-wiki-handle-interwiki (&optional string)
  "If STRING or point has an interwiki link, resolve it and
return the first match.
Match 1 is set to the link.
Match 2 is set to the description."
  (when (if string (string-match muse-wiki-interwiki-regexp string)
          (looking-at muse-wiki-interwiki-regexp))
    (let* ((project (match-string 1 string))
           (subst (cdr (assoc project muse-wiki-interwiki-alist)))
           (word (match-string 2 string)))
      (if subst
          (if (functionp subst)
              (funcall subst word)
            (concat subst word))
        (and (assoc project muse-project-alist)
             (muse-wiki-resolve-project-page project word))))))

(defun muse-wiki-handle-wikiword (&optional string)
  "If STRING or point has a WikiWord, return it.
Match 1 is set to the WikiWord."
  (when (and muse-wiki-use-wikiword
             (if string
                 (string-match muse-wiki-wikiword-regexp string)
               (looking-at muse-wiki-wikiword-regexp))
             (or (and (muse-project-of-file)
                      (muse-project-page-file
                       (match-string 1 string) muse-current-project t))
                 (file-exists-p (match-string 1 string))))
    (match-string 1 string)))

;; Pretty title

(defcustom muse-wiki-publish-small-title-words
  '("the" "and" "at" "on" "of" "for" "in" "an" "a")
  "Strings that should be downcased in a page title.
This is used by `muse-wiki-publish-pretty-title', which must be
called manually."
  :type '(repeat string)
  :group 'muse-wiki)

(defun muse-wiki-publish-pretty-title (&optional title)
  "Return a pretty version of the given TITLE."
  (unless title (setq title (muse-publishing-directive "title")))
  (save-match-data
    (let ((case-fold-search nil))
      (while (string-match (concat "\\([" muse-regexp-upper
                                   muse-regexp-lower
                                   "]\\)\\([" muse-regexp-upper
                                   "0-9]\\)")
                           title)
        (setq title (replace-match "\\1 \\2" t nil title)))
      (let* ((words (split-string title))
             (w (cdr words)))
        (while w
          (if (member (downcase (car w))
                      muse-wiki-publish-small-title-words)
              (setcar w (downcase (car w))))
          (setq w (cdr w)))
        (mapconcat 'identity words " ")))))

;; Coloring setup

(eval-after-load "muse-colors"
  '(progn
     (defun muse-wiki-colors-wikiword ()
       "Color WikiWords."
       ;; remove flyspell overlays
       (when (fboundp 'flyspell-unhighlight-at)
         (let ((cur (match-beginning 0)))
           (while (> (match-end 0) cur)
             (flyspell-unhighlight-at cur)
             (setq cur (1+ cur)))))
       (let ((link (muse-match-string-no-properties 1))
             (face (muse-link-face (match-string 1))))
         (when face
           (add-text-properties (match-beginning 1) (match-end 0)
                                (muse-link-properties
                                 (muse-match-string-no-properties 1) face)))))

     (defun muse-wiki-colors-nop-tag (beg end)
       (add-text-properties beg (+ beg 5)
                            '(invisible muse intangible t)))

     (add-to-list 'muse-colors-tags
                  '("nop" nil nil muse-wiki-colors-nop-tag)
                  t)

     (add-to-list 'muse-colors-markup
                  '(muse-wiki-interwiki-regexp t muse-wiki-colors-wikiword)
                  t)
     (add-to-list 'muse-colors-markup
                  '(muse-wiki-wikiword-regexp t muse-wiki-colors-wikiword)
                  t)

     (muse-configure-highlighting 'muse-colors-markup muse-colors-markup)))

;; Publishing setup

(eval-after-load "muse-publish"
  '(progn
     (add-to-list 'muse-publish-markup-regexps
                  '(3100 muse-wiki-interwiki-regexp 0 link)
                  t)
     (add-to-list 'muse-publish-markup-regexps
                  '(3200 muse-wiki-wikiword-regexp 0 link)
                  t)))

;; Insinuate link handling

(add-to-list 'muse-implicit-link-functions
             'muse-wiki-handle-interwiki t)
(add-to-list 'muse-implicit-link-functions
             'muse-wiki-handle-wikiword t)

(add-to-list 'muse-explicit-link-functions
             'muse-wiki-handle-interwiki t)

;; Update several things when Muse mode is entered
(defun muse-wiki-update-custom-values ()
  "Update some important muse-wiki values that may have been altered manually."
  (muse-wiki-update-interwiki-regexp muse-wiki-interwiki-alist))

(add-hook 'muse-mode-hook
          'muse-wiki-update-custom-values)

(provide 'muse-wiki)
;;; muse-wiki.el ends here
